# 014 — LEI 11: Pipeline resumível (checkpoint)

**Data**: 2026-02-21  
**Fonte**: AGENT_LLM_COMMUNICATION_ANALYSIS.md § LEI 11

## Objetivo

O pipeline deve poder retomar após falha sem refazer etapas já concluídas. Persistência do PipelineContext via checkpoint.

## Implementação (pipeline_context.py)

- **current_step: int = 0** em `__init__`: etapa atual (0 = início); o runner pode incrementar após cada fase e usar para pular etapas já feitas.
- **save_checkpoint(storage_path: str | Path)**:
  - Monta dict com project_id, spec_raw, product_spec, product_spec_template, engineer_proposal, charter, backlog, current_module, current_task, artifacts, completed_tasks, current_step, saved_at (ISO UTC).
  - Grava em `storage_path / project_id / checkpoint.json` (mkdir parents, json.dump com ensure_ascii=False, indent=2).
  - Log: "Checkpoint salvo (LEI 11): step=..., tasks=...".
- **load_checkpoint(storage_path, project_id) -> PipelineContext | None** (classmethod):
  - Lê `storage_path / project_id / checkpoint.json`; se não existir, retorna None.
  - Cria instância, restaura todos os campos e retorna. Log: "Checkpoint restaurado (LEI 11): step=..., tasks=...".

## Uso no runner (integrado)

- **Início do fluxo V2**: `ensure_state_dir()`; `loaded = PipelineContext.load_checkpoint(STATE_DIR, project_id)`. Se não None, `pipeline_ctx = loaded` e log "Checkpoint restaurado (LEI 11): step=..., retomando...". Senão, criar novo contexto e set_spec_raw/template. Em seguida preencher `spec_understood`, `charter_summary`, `engineer_summary`, `backlog_summary` a partir de `pipeline_ctx` (para uso quando fases forem puladas).
- **Fase 1 — CTO spec**: executar só se `not pipeline_ctx or pipeline_ctx.current_step < 1`. Ao fim: `pipeline_ctx.current_step = 1`; `pipeline_ctx.save_checkpoint(STATE_DIR)`.
- **Fase 2 — CTO↔Engineer / Charter**: executar só se `current_step < 2`. Ao fim: `current_step = 2`; `save_checkpoint(STATE_DIR)`.
- **Fase 3 — PM / Backlog**: executar só se `current_step < 3`. Ao fim: `set_backlog(backlog_summary)`; `current_step = 3`; `save_checkpoint(STATE_DIR)`.
- Monitor Loop segue sempre que API disponível (não depende de step).

## Testes

- **test_pipeline_context_lei11_save_and_load_checkpoint(tmp_path)**: cria contexto, preenche, save_checkpoint, load_checkpoint, assert campos iguais (spec_raw, product_spec, charter, current_step, artifacts, completed_tasks).
- **test_pipeline_context_lei11_load_checkpoint_missing_returns_none**: load para project_id inexistente retorna None.

## Checklist

| # | Item | Status |
|---|------|--------|
| 1 | current_step + save_checkpoint + load_checkpoint | Concluído |
| 2 | Testes LEI 11 | Concluído |

## Próximos

- Integrar load/save no runner (tentar load no início; save após cada fase).
- LEI 12 já implementada (QA ceticismo no SYSTEM_PROMPT).
